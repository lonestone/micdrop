import { toJSONSchema, z } from 'zod'

export interface Tool<Schema extends z.ZodObject = z.ZodObject> {
  name: string
  description: string
  inputSchema?: Schema
  execute?: (input: z.infer<Schema>) => any | Promise<any>
  skipAnswer?: boolean
  emitOutput?: boolean
}

// Similar types as OpenAI
export interface ToolCall {
  /**
   * A JSON string of the arguments to pass to the function.
   */
  arguments: string

  /**
   * The unique ID of the function tool call generated by the model.
   */
  call_id: string

  /**
   * The name of the function to run.
   */
  name: string

  /**
   * The type of the function tool call. Always `function_call`.
   */
  type: 'function_call'

  /**
   * The unique ID of the function tool call.
   */
  id?: string

  /**
   * The status of the item. One of `in_progress`, `completed`, or `incomplete`.
   * Populated when items are returned via API.
   */
  status?: 'in_progress' | 'completed' | 'incomplete'
}

export interface ToolCallOutput {
  /**
   * The unique ID of the function tool call generated by the model.
   */
  call_id: string

  /**
   * A JSON string of the output of the function tool call.
   */
  output: string

  /**
   * The type of the function tool call output. Always `function_call_output`.
   */
  type: 'function_call_output'

  /**
   * The unique ID of the function tool call output. Populated when this item is
   * returned via API.
   */
  id?: string | null

  /**
   * The status of the item. One of `in_progress`, `completed`, or `incomplete`.
   * Populated when items are returned via API.
   */
  status?: 'in_progress' | 'completed' | 'incomplete' | null
}

export function createToolSchema<Schema extends z.ZodObject>(
  tool: Tool<Schema>
) {
  return {
    type: 'function',
    name: tool.name,
    description: tool.description,
    strict: true,
    parameters: toJSONSchema(tool.inputSchema || z.object()),
  } as const
}

export function createToolCallOutput(
  toolCall: ToolCall,
  args: any
): ToolCallOutput {
  return {
    type: 'function_call_output',
    call_id: toolCall.call_id,
    output: JSON.stringify(args ?? null),
  }
}

export const AUTO_END_CALL_TOOL_NAME = 'end_call'
export const AUTO_END_CALL_PROMPT =
  'Call this tool only if user asks to end the call'

export const AUTO_SEMANTIC_TURN_TOOL_NAME = 'semantic_turn'
export const AUTO_SEMANTIC_TURN_PROMPT =
  'Call this tool only if last user message is obviously an incomplete sentence that you need to wait for the end before answering'

export const AUTO_IGNORE_USER_NOISE_TOOL_NAME = 'ignore_user_noise'
export const AUTO_IGNORE_USER_NOISE_PROMPT =
  'Call this tool only if last user message is just an interjection or a sound that expresses emotion, hesitation, or reaction (ex: "Uh", "Ahem", "Hmm", "Ah") but doesn\'t carry any clear meaning like agreeing, refusing, or commanding'
